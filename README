Compile: make / make all
Run tests: make clean && make TEST=1
Run in qemu: make qemu / make qemu-nox
Debug with gdb: make qemu-gdb / make qemu-nox-gdb
                (in another terminal) gdb

To use your solutions from lab 1: git merge lab1
To use sample lab 1 solutions: copy files in samples/ to appropriate directories

I worked with Benjamin Chen (netID: blc38)
We coded this assignment together.

## Part 1

In this part, we first register appropriate trap handlers for each trap number. This just consists of calling the exception, interrupt, and syscall_dispatch handlers for cooresponding trap numbers.

We also included spinlocks in kern/dev/console.c and kern/lib/debug.c to protect the cons and dprintf resources respectively. We added a spinlock in PThread for each cpu to protect the ready thread queue for each cpu on thread_spawn and thread_yield calls.

## Part 2

In this part, we introduced clock interrupts and preemption by first defining a sched_update function that keeps track of elapsed time since last thread switch for each cpu. Upon each LAPIC timer interrupt, this elapsed time is checked and if it exceeds SCHED_SLICE, the current cpu is forced to switch threads. We then call this sched_update function in the interrupt handler to check elapsed time every timer interrupt.

## Part 3

In this part, we temporarily enable interrupts during sys_consume and sys_produce execution. This ensures that we are able to use timer interrupts to switch between producing and consuming threads. We also then disable interrupts during any printing function inside each of these syscalls to ensure that the kernel is not preempted when it executes its printing code. Finally, we have added 3 specific error checks (for exceeding the quota, exceeding the max number of children, and for invalid child ids) within the sys_spawn call. This ensures that when trying to create a new thread from an existing one that the container conditions are able to support this new child thread before it is created.

## Part 4:

For the Producer-Consumer problem, we implemented a bounded buffer queue. There are two condition variables - whether 
if the queue is full or empty and thus, we need two sleep queues, one for the producers and one for the consumers. During a call to wait(), 
the currently running thread is placed on the thread's respective sleep queue, and then the next thread on the CPU's ready list is set to run (context switch).
Furthermore, during a call to signal(), the thread takes another thread from the opposite CPU's waiting list and queues it in the opposite CPU's ready list. 
This way, whenever the queue is full, the producers should be on their own sleeping list with the only thread running being the idle thread. Moreover, the consumers
should begin running, taking producer threads from their sleep list and appending to their ready list as the consumers call signal(). We make sure to keep wait() 
in a while loop.